/**
 * MENU SYSTEM - Sistema de Men√∫s
 *
 * Gestiona todos los men√∫s del juego:
 * - Men√∫ principal
 * - Configuraci√≥n
 * - Puntuaciones altas
 * - Instrucciones
 */

export class MenuSystem {
  constructor(game) {
    console.log("üìã [MENU] Inicializando sistema de men√∫...")

    this.game = game
    this.domElements = {}
    this.isVisible = false
    this.isInitialized = false

    // CORREGIDO: Inicializar inmediatamente sin esperar
    this.initialize()
  }

  /**
   * CORREGIDO: Inicializa el sistema de men√∫ de forma s√≠ncrona
   */
  initialize() {
    console.log("üöÄ [MENU] Inicializando elementos del men√∫...")
    
    this.initializeElements()

    try {
      if (!this.initializeElements()) {
        console.error("‚ùå [MENU] Error inicializando elementos")
        // CORREGIDO: Reintentar despu√©s de un breve delay
        setTimeout(() => {
          console.log("üîÑ [MENU] Reintentando inicializaci√≥n...")
          this.initialize()
        }, 100)
        return
      }

      this.setupEventListeners()
      this.setupAnimations()
      this.isInitialized = true

      console.log("‚úÖ [MENU] Sistema de men√∫ inicializado correctamente")
    } catch (error) {
      console.error("‚ùå [MENU] Error en inicializaci√≥n:", error)
    }
  }

  /**
   * CORREGIDO: Inicializa las referencias a elementos DOM con mejor logging
   */
  initializeElements() {
    console.log("üîç [MENU] Buscando elementos DOM...")

    const elementIds = [
      "menuOverlay",
      "startGameButton",
      "instructionsButton",
      "highScoresButton",
      "timeSelect",
      "aimLineToggle",
      "pointerStyleSelect",
      "trajectoryToggle",
      "controlModeSelect",
      "soundToggle",
      "scoresModal",
      "closeScoresButton",
    ]

    let foundElements = 0
    const missingElements = []

    elementIds.forEach((id) => {
      const element = document.getElementById(id)
      if (element) {
        this.domElements[id] = element
        foundElements++
        console.log(`‚úÖ [MENU] Elemento encontrado: ${id}`)
      } else {
        missingElements.push(id)
        console.warn(`‚ö†Ô∏è [MENU] Elemento no encontrado: ${id}`)
      }
    })

    // CORREGIDO: Logging detallado de elementos faltantes
    if (missingElements.length > 0) {
      console.error("‚ùå [MENU] Elementos faltantes:", missingElements)
      console.log(
        "üîç [MENU] Elementos disponibles en DOM:",
        Array.from(document.querySelectorAll("[id]")).map((el) => el.id),
      )
    }

    // Verificar elemento cr√≠tico
    if (!this.domElements.menuOverlay) {
      console.error("‚ùå [MENU] menuOverlay no encontrado - men√∫ no funcionar√°")
      return false
    }

    if (!this.domElements.startGameButton) {
      console.error("‚ùå [MENU] startGameButton no encontrado - no se puede iniciar juego")
      return false
    }

    console.log(`üìä [MENU] ${foundElements}/${elementIds.length} elementos encontrados`)
    return foundElements >= 2 // Al menos menuOverlay y startGameButton
  }
  
  /**
   * CORREGIDO: Configura los event listeners del men√∫ con elementos interactivos
   */
  setupEventListeners() {
    console.log("üéß [MENU] Configurando event listeners del men√∫...")

    // Limpiar listeners existentes para evitar duplicados
    this.removeExistingListeners()

    // CORREGIDO: Configurar todos los botones
    this.setupAllButtons()

    // CORREGIDO: Configurar elementos interactivos (selects, checkboxes)
    this.setupInteractiveElements()

    // Event listeners para cambios en configuraci√≥n
    this.setupConfigurationListeners()

    console.log("‚úÖ [MENU] Todos los event listeners configurados")
  }

  /**
   * NUEVO: Configura elementos interactivos (selects, checkboxes) SIN animaciones de hover
   */
  setupInteractiveElements() {
    console.log("üéõÔ∏è [MENU] Configurando elementos interactivos...")

    // Configurar selects
    const selects = ["timeSelect", "pointerStyleSelect", "controlModeSelect"]
    selects.forEach((selectId) => {
      const select = this.domElements[selectId]
      if (select) {
        // CORREGIDO: Prevenir interferencias de hover del contenedor padre
        const parentGroup = select.closest(".option-group")
        if (parentGroup) {
          parentGroup.style.pointerEvents = "auto"
        }

        select.addEventListener("change", (e) => {
          console.log(`üéõÔ∏è [MENU] Select cambiado: ${selectId} = ${e.target.value}`)
          this.saveCurrentSettings()
        })

        console.log(`‚úÖ [MENU] Select configurado: ${selectId}`)
      }
    })

    // Configurar checkboxes
    const checkboxes = ["aimLineToggle", "trajectoryToggle", "soundToggle"]
    checkboxes.forEach((checkboxId) => {
      const checkbox = this.domElements[checkboxId]
      if (checkbox) {
        // CORREGIDO: Prevenir interferencias de hover del contenedor padre
        const parentGroup = checkbox.closest(".option-group")
        if (parentGroup) {
          parentGroup.style.pointerEvents = "auto"
        }

        checkbox.addEventListener("change", (e) => {
          console.log(`‚òëÔ∏è [MENU] Checkbox cambiado: ${checkboxId} = ${e.target.checked}`)
          this.saveCurrentSettings()
        })

        console.log(`‚úÖ [MENU] Checkbox configurado: ${checkboxId}`)
      }
    })
  }

  /**
   * CORREGIDO: Configuraci√≥n robusta de TODOS los botones
   */
  setupAllButtons() {
    // Configurar bot√≥n de inicio
    this.setupButton("startGameButton", "üéÆ [MENU] Bot√≥n iniciar presionado", () => {
      this.handleStartGame()
    })

    // Configurar bot√≥n de instrucciones
    this.setupButton("instructionsButton", "üìñ [MENU] Bot√≥n instrucciones presionado", () => {
      this.showInstructions()
    })

    // Configurar bot√≥n de puntuaciones
    this.setupButton("highScoresButton", "üèÜ [MENU] Bot√≥n puntuaciones presionado", () => {
      this.showHighScores()
    })

    // Configurar bot√≥n de cerrar puntuaciones
    this.setupButton("closeScoresButton", "üèÜ [MENU] Cerrando puntuaciones", () => {
      this.hideHighScores()
    })
  }
  
  /**
   * NUEVO: M√©todo gen√©rico para configurar cualquier bot√≥n
   */
  setupButton(buttonId, logMessage, callback) {
    const button = this.domElements[buttonId]
    if (!button) {
      console.warn(`‚ö†Ô∏è [MENU] Bot√≥n no encontrado: ${buttonId}`)
      return
    }

    // Asegurar que el bot√≥n est√© visible y habilitado
    button.style.display = "inline-block"
    button.style.visibility = "visible"
    button.style.pointerEvents = "auto"
    button.disabled = false
    button.classList.remove("loading")

    // Handler unificado
    const handleClick = (e) => {
      e.preventDefault()
      e.stopPropagation()
      console.log(logMessage)
      console.log(`üîç [MENU] Elemento: ${buttonId}, Tipo evento: ${e.type}`)

      try {
        callback()
      } catch (error) {
        console.error(`‚ùå [MENU] Error en ${buttonId}:`, error)
      }
    }

    // M√∫ltiples event listeners para asegurar funcionamiento
    button.addEventListener("touchstart", handleClick, { passive: false })

    // Log de verificaci√≥n
    console.log(`‚úÖ [MENU] Bot√≥n configurado: ${buttonId}`)
    console.log(`  - Display: ${getComputedStyle(button).display}`)
    console.log(`  - Visibility: ${getComputedStyle(button).visibility}`)
    console.log(`  - Pointer Events: ${getComputedStyle(button).pointerEvents}`)
  }
  
  /**
   * Remueve listeners existentes para evitar duplicados
   */
  removeExistingListeners() {
    const elements = [
      this.domElements.startGameButton,
      this.domElements.instructionsButton,
      this.domElements.highScoresButton,
      this.domElements.closeScoresButton,
    ]

    elements.forEach((element) => {
      if (element) {
        const newElement = element.cloneNode(true)
        element.parentNode.replaceChild(newElement, element)
        // Actualizar referencia
        this.domElements[element.id] = newElement
      }
    })
  }

  /**
   * Configura listeners para cambios de configuraci√≥n
   */
  setupConfigurationListeners() {
    const configElements = [
      "timeSelect",
      "aimLineToggle",
      "pointerStyleSelect",
      "trajectoryToggle",
      "controlModeSelect",
      "soundToggle",
    ]

    configElements.forEach((elementId) => {
      const element = this.domElements[elementId]
      if (element) {
        element.addEventListener("change", () => {
          console.log(`‚öôÔ∏è [MENU] Configuraci√≥n cambiada: ${elementId}`)
          this.saveCurrentSettings()
        })
      }
    })
  }
  
  /**
   * Configura animaciones del men√∫
   */
  setupAnimations() {
    // A√±adir clases de animaci√≥n a elementos
    if (this.domElements.menuOverlay) {
      this.domElements.menuOverlay.classList.add("menu-animated")
    }

    // Configurar animaciones de botones
    const buttons = [
      this.domElements.startGameButton,
      this.domElements.instructionsButton,
      this.domElements.highScoresButton,
    ]

    buttons.forEach((button, index) => {
      if (button) {
        button.style.animationDelay = `${0.8 + index * 0.1}s`
      }
    })
  }

  /**
   * CORREGIDO: Maneja el inicio del juego con mejor logging
   */
  handleStartGame() {
    console.log("üéÆ [MENU] === INICIANDO PROCESO DE JUEGO ===")

    try {
      // Verificar que el sistema est√© listo
      if (!this.isInitialized) {
        console.error("‚ùå [MENU] Sistema no inicializado")
        return
      }

      if (!this.game) {
        console.error("‚ùå [MENU] Objeto game no disponible")
        return
      }

      // A√±adir clase de loading al bot√≥n
      const startButton = this.domElements.startGameButton
      if (startButton) {
        startButton.classList.add("loading")
        startButton.disabled = true
        console.log("üîÑ [MENU] Bot√≥n en estado loading")
      }

      // Obtener configuraci√≥n
      const settings = this.getGameSettings()
      console.log("‚öôÔ∏è [MENU] Configuraci√≥n obtenida:", settings)

      // Validar configuraci√≥n
      if (!this.validateSettings(settings)) {
        console.error("‚ùå [MENU] Configuraci√≥n inv√°lida")
        this.resetStartButton()
        return
      }

      console.log("üéØ [MENU] Iniciando secuencia de juego...")

      // Verificar m√©todo startGame
      if (typeof this.game.startGame !== "function") {
        console.error("‚ùå [MENU] M√©todo startGame no existe en game object")
        console.log("üîç [MENU] M√©todos disponibles en game:", Object.getOwnPropertyNames(this.game))
        this.resetStartButton()
        return
      }

      // Ocultar men√∫ con animaci√≥n
      this.hide()

      // Iniciar juego despu√©s de la animaci√≥n
      setTimeout(() => {
        console.log("üöÄ [MENU] Llamando game.startGame()...")
        this.game.startGame(settings)
        console.log("‚úÖ [MENU] Juego iniciado correctamente")
        this.resetStartButton()
      }, 300)
    } catch (error) {
      console.error("‚ùå [MENU] Error iniciando juego:", error)
      console.error("‚ùå [MENU] Stack trace:", error.stack)
      this.resetStartButton()
      this.show()
      alert("Error al iniciar el juego. Por favor, verifica la configuraci√≥n.")
    }
  }
  
  /**
   * Resetea el bot√≥n de inicio
   */
  resetStartButton() {
    const startButton = this.domElements.startGameButton
    if (startButton) {
      startButton.classList.remove("loading")
      startButton.disabled = false
      console.log("üîÑ [MENU] Bot√≥n reseteado")
    }
  }

  /**
   * Valida la configuraci√≥n del juego
   */
  validateSettings(settings) {
    const requiredFields = ["timeLimit", "showAimLine", "controlMode", "pointerStyle", "showTrajectory", "soundEnabled"]

    for (const field of requiredFields) {
      if (settings[field] === undefined || settings[field] === null) {
        console.error(`‚ùå [MENU] Campo requerido faltante: ${field}`)
        return false
      }
    }

    // Validar rangos
    if (settings.timeLimit < 30 || settings.timeLimit > 120) {
      console.error("‚ùå [MENU] Tiempo l√≠mite fuera de rango")
      return false
    }

    return true
  }

  /**
   * Obtiene la configuraci√≥n actual del men√∫
   */
  getGameSettings() {
    const settings = {
      timeLimit: Number.parseInt(this.domElements.timeSelect?.value || "60"),
      showAimLine: this.domElements.aimLineToggle?.checked || true,
      controlMode: this.domElements.controlModeSelect?.value || "flipper",
      pointerStyle: this.domElements.pointerStyleSelect?.value || "orbital",
      showTrajectory: this.domElements.trajectoryToggle?.checked || true,
      soundEnabled: this.domElements.soundToggle?.checked || false,
    }

    console.log("üìã [MENU] Configuraci√≥n actual:", settings)
    return settings
  }

  /**
   * Guarda la configuraci√≥n actual
   */
  saveCurrentSettings() {
    try {
      const settings = this.getGameSettings()
      if (this.game && this.game.storageManager) {
        this.game.storageManager.saveSettings(settings)
        console.log("üíæ [MENU] Configuraci√≥n guardada:", settings)
      }
    } catch (error) {
      console.warn("‚ö†Ô∏è [MENU] Error guardando configuraci√≥n:", error)
    }
  }

  /**
   * Muestra las instrucciones del juego
   */
  showInstructions() {
    console.log("üìñ [MENU] Mostrando instrucciones...")

    const instructions = `üåü STELLAR POOL - INSTRUCCIONES üåü

üéØ OBJETIVO:
- Mete las estrellas en los agujeros activos (brillan en amarillo)
- Completa todos los niveles antes de que se acabe el tiempo

üéÆ CONTROLES:
- Arrastra una estrella para apuntar y disparar
- Usa las flechas del teclado para mover la c√°mara
- Presiona ESPACIO para cambiar de estrella
- Presiona ESC para pausar el juego

‚≠ê ESTRELLAS:
- Amarilla: Estrella principal
- Azul: Estrella de precisi√≥n  
- Roja: Estrella de potencia

üöÄ POWER-UPS:
- Morado: C√°mara lenta (5 segundos)
- Azul: Escudo protector (8 segundos)
- Naranja: Im√°n magn√©tico (6 segundos)

üí• OBST√ÅCULOS:
- Meteoritos rojos: Te quitan puntos y te regresan al inicio
- Agujeros incorrectos: Penalizaci√≥n de puntos`

    alert(instructions)
  }
  
}